#include <compare>  // see [compare.syn]
#include <experimental/meta>
#include <array>
#include <utility>
#include <type_traits>
#include <memory>

#ifndef RSL_STD_COMPAT
#define RSL_STD_COMPAT 1
#endif

#if RSL_STD_COMPAT
#  include <tuple>
#endif

namespace rsl {
// [tuple.tuple], class template tuple
template <class... Types>
class tuple;

// ignore
namespace _tuple_impl {
#if RSL_STD_COMPAT
using ignore_type = decltype(std::ignore);
#else
struct ignore_type {  // exposition only
  constexpr ignore_type const& operator=(const auto&) const noexcept { return *this; }
};
#endif
}  // namespace _tuple_impl

inline constexpr _tuple_impl::ignore_type ignore;

// [tuple.helper], tuple helper classes
template <class T>
struct tuple_size;  // not defined

template <class T>
struct tuple_size<const T> : tuple_size<T> {};

template <class... Types>
struct tuple_size<tuple<Types...>> : std::integral_constant<std::size_t, sizeof...(Types)> {};

template <class T>
constexpr std::size_t tuple_size_v = tuple_size<T>::value;

template <std::size_t I, class T>
struct tuple_element;  // not defined

template <std::size_t I, class... Types>
struct tuple_element<I, tuple<Types...> const> {
    using type = Types...[I] const;
};

template <std::size_t I, class... Types>
struct tuple_element<I, tuple<Types...>> {
    using type = Types...[I];
};

template <std::size_t I, class T>
using tuple_element_t = typename tuple_element<I, T>::type;

// [tuple.like], concept tuple-like
// TODO ranges::subrange
template <class T>
concept tuple_like =
    has_template_arguments(^^T) &&
    (template_of(^^T) == ^^std::array || template_of(^^T) == ^^std::complex ||
     template_of(^^T) == ^^std::pair || template_of(^^T) == ^^tuple);  // exposition only

template <class... Types>
class tuple {
private:
    struct Storage;

    consteval {
        define_aggregate(^^Storage, {data_member_spec(^^Types)...});
    };

    Storage storage;
public:
  // [tuple.cnstr], tuple construction
  constexpr explicit(true /* TODO*/) tuple() = default;

  constexpr explicit(true /* TODO*/) tuple(const Types&... values)
    requires (sizeof...(Types) >= 1)
    : storage{values...}{}

//   template <class... UTypes>
//   constexpr explicit(true /* TODO*/) tuple(UTypes&&...);  // only if sizeof...(Types) >= 1

//   tuple(const tuple&) = default;
//   tuple(tuple&&)      = default;

//   template <class... UTypes>
//   constexpr explicit(true /* TODO*/) tuple(tuple<UTypes...>&);
//   template <class... UTypes>
//   constexpr explicit(true /* TODO*/) tuple(const tuple<UTypes...>&);
//   template <class... UTypes>
//   constexpr explicit(true /* TODO*/) tuple(tuple<UTypes...>&&);
//   template <class... UTypes>
//   constexpr explicit(true /* TODO*/) tuple(const tuple<UTypes...>&&);

//   template <class U1, class U2>
//   constexpr explicit(true /* TODO*/) tuple(std::pair<U1, U2>&);  // only if sizeof...(Types) == 2
//   template <class U1, class U2>
//   constexpr explicit(true /* TODO*/)
//       tuple(const std::pair<U1, U2>&);  // only if sizeof...(Types) == 2
//   template <class U1, class U2>
//   constexpr explicit(true /* TODO*/) tuple(std::pair<U1, U2>&&);  // only if sizeof...(Types) == 2
//   template <class U1, class U2>
//   constexpr explicit(true /* TODO*/)
//       tuple(const std::pair<U1, U2>&&);  // only if sizeof...(Types) == 2

//   template <tuple_like UTuple>
//   constexpr explicit(true /* TODO*/) tuple(UTuple&&);

//   // allocator-extended constructors
//   template <class Alloc>
//   constexpr explicit(true /* TODO*/) tuple(std::allocator_arg_t, const Alloc& a);
//   template <class Alloc>
//   constexpr explicit(true /* TODO*/) tuple(std::allocator_arg_t, const Alloc& a, const Types&...);
//   template <class Alloc, class... UTypes>
//   constexpr explicit(true /* TODO*/) tuple(std::allocator_arg_t, const Alloc& a, UTypes&&...);
//   template <class Alloc>
//   constexpr tuple(std::allocator_arg_t, const Alloc& a, const tuple&);
//   template <class Alloc>
//   constexpr tuple(std::allocator_arg_t, const Alloc& a, tuple&&);
//   template <class Alloc, class... UTypes>
//   constexpr explicit(true /* TODO*/) tuple(std::allocator_arg_t, const Alloc& a, tuple<UTypes...>&);
//   template <class Alloc, class... UTypes>
//   constexpr explicit(true /* TODO*/)
//       tuple(std::allocator_arg_t, const Alloc& a, const tuple<UTypes...>&);
//   template <class Alloc, class... UTypes>
//   constexpr explicit(true /* TODO*/)
//       tuple(std::allocator_arg_t, const Alloc& a, tuple<UTypes...>&&);
//   template <class Alloc, class... UTypes>
//   constexpr explicit(true /* TODO*/)
//       tuple(std::allocator_arg_t, const Alloc& a, const tuple<UTypes...>&&);
//   template <class Alloc, class U1, class U2>
//   constexpr explicit(true /* TODO*/)
//       tuple(std::allocator_arg_t, const Alloc& a, std::pair<U1, U2>&);
//   template <class Alloc, class U1, class U2>
//   constexpr explicit(true /* TODO*/)
//       tuple(std::allocator_arg_t, const Alloc& a, const std::pair<U1, U2>&);
//   template <class Alloc, class U1, class U2>
//   constexpr explicit(true /* TODO*/)
//       tuple(std::allocator_arg_t, const Alloc& a, std::pair<U1, U2>&&);
//   template <class Alloc, class U1, class U2>
//   constexpr explicit(true /* TODO*/)
//       tuple(std::allocator_arg_t, const Alloc& a, const std::pair<U1, U2>&&);

//   template <class Alloc, tuple_like UTuple>
//   constexpr explicit(true /* TODO*/) tuple(std::allocator_arg_t, const Alloc& a, UTuple&&);

    //! non-standard: get member function
    template <std::size_t I, class Self>
    constexpr decltype(auto) get(this Self&& self) {
        // TODO cache nsdms
        return std::forward_like<Self>(std::forward<Self>(self).storage.[:nonstatic_data_members_of(^^Storage)[I]:]);
    }

//   // [tuple.assign], tuple assignment
//   constexpr tuple& operator=(const tuple&);
//   constexpr const tuple& operator=(const tuple&) const;
//   constexpr tuple& operator=(tuple&&) noexcept(true /* TODO */);
//   constexpr const tuple& operator=(tuple&&) const;

//   template <class... UTypes>
//   constexpr tuple& operator=(const tuple<UTypes...>&);
//   template <class... UTypes>
//   constexpr const tuple& operator=(const tuple<UTypes...>&) const;
//   template <class... UTypes>
//   constexpr tuple& operator=(tuple<UTypes...>&&);
//   template <class... UTypes>
//   constexpr const tuple& operator=(tuple<UTypes...>&&) const;

//   template <class U1, class U2>
//   constexpr tuple& operator=(const std::pair<U1, U2>&);  // only if sizeof...(Types) == 2
//   template <class U1, class U2>
//   constexpr const tuple& operator=(const std::pair<U1, U2>&) const;
//   // only if sizeof...(Types) == 2
//   template <class U1, class U2>
//   constexpr tuple& operator=(std::pair<U1, U2>&&);  // only if sizeof...(Types) == 2
//   template <class U1, class U2>
//   constexpr const tuple& operator=(std::pair<U1, U2>&&) const;  // only if sizeof...(Types) == 2

//   template <tuple_like UTuple>
//   constexpr tuple& operator=(UTuple&&);
//   template <tuple_like UTuple>
//   constexpr const tuple& operator=(UTuple&&) const;

//   // [tuple.swap], tuple swap
//   constexpr void swap(tuple&) noexcept(true /* TODO */);
//   constexpr void swap(const tuple&) const noexcept(true /* TODO */);
};

template <class... UTypes>
tuple(UTypes...) -> tuple<UTypes...>;
template <class T1, class T2>
tuple(std::pair<T1, T2>) -> tuple<T1, T2>;
template <class Alloc, class... UTypes>
tuple(std::allocator_arg_t, Alloc, UTypes...) -> tuple<UTypes...>;
template <class Alloc, class T1, class T2>
tuple(std::allocator_arg_t, Alloc, std::pair<T1, T2>) -> tuple<T1, T2>;
template <class Alloc, class... UTypes>
tuple(std::allocator_arg_t, Alloc, tuple<UTypes...>) -> tuple<UTypes...>;

// [tuple.creation], tuple creation functions
// template <class... TTypes>
// constexpr tuple<std::unwrap_ref_decay_t<TTypes>...> make_tuple(TTypes&&...);

// template <class... TTypes>
// constexpr tuple<TTypes&&...> forward_as_tuple(TTypes&&...) noexcept;

// template <class... TTypes>
// constexpr tuple<TTypes&...> tie(TTypes&...) noexcept;

// template <tuple_like... Tuples>
// constexpr tuple<CTypes...> tuple_cat(Tuples&&...);

// [tuple.apply], calling a function with a tuple of arguments
// template <class F, tuple_like Tuple>
// constexpr decltype(auto) apply(F&& f, Tuple&& t) noexcept(true /*TODO*/);

// template <class T, tuple_like Tuple>
// constexpr T make_from_tuple(Tuple&& t);

// [tuple.elem], element access
template <std::size_t I, class... Types>
constexpr tuple_element_t<I, tuple<Types...>>& get(tuple<Types...>& obj) noexcept {
    return obj.template get<I>();
}

template <std::size_t I, class... Types>
constexpr tuple_element_t<I, tuple<Types...>>&& get(tuple<Types...>&& obj) noexcept {
    return std::move(obj).template get<I>();
}

template <std::size_t I, class... Types>
constexpr tuple_element_t<I, tuple<Types...>> const& get(tuple<Types...> const& obj) noexcept {
    return obj.template get<I>();
}

template <std::size_t I, class... Types>
constexpr tuple_element_t<I, tuple<Types...>> const&& get(tuple<Types...> const&& obj) noexcept {
    return static_cast<tuple<Types...> const&&>(obj).template get<I>();
}

// template <class T, class... Types>
// constexpr T& get(tuple<Types...>& t) noexcept;
// template <class T, class... Types>
// constexpr T&& get(tuple<Types...>&& t) noexcept;
// template <class T, class... Types>
// constexpr const T& get(const tuple<Types...>& t) noexcept;
// template <class T, class... Types>
// constexpr const T&& get(const tuple<Types...>&& t) noexcept;

// [tuple.rel], relational operators
// template <class... TTypes, class... UTypes>
// constexpr bool operator==(const tuple<TTypes...>&, const tuple<UTypes...>&);
// template <class... TTypes, tuple_like UTuple>
// constexpr bool operator==(const tuple<TTypes...>&, const UTuple&);
// template <class... TTypes, class... UTypes>
// constexpr std::common_comparison_category_t<synth_three_way_result<TTypes, UTypes>...> operator<=>(
//     const tuple<TTypes...>&,
//     const tuple<UTypes...>&);
// template <class... TTypes, tuple_like UTuple>
// constexpr std::common_comparison_category_t<synth_three_way_result<TTypes, Elems>...> operator<=>(
//     const tuple<TTypes...>&,
//     const UTuple&);

// [tuple.special], specialized algorithms
// template <class... Types>
// constexpr void swap(tuple<Types...>& x, tuple<Types...>& y) noexcept(true /* TODO */);
// template <class... Types>
// constexpr void swap(const tuple<Types...>& x, const tuple<Types...>& y) noexcept(true /* TODO */);

}  // namespace rsl

// [tuple.common.ref], common_reference related specializations
// template <rsl::tuple_like TTuple,
//           rsl::tuple_like UTuple,
//           template <class> class TQual,
//           template <class> class UQual>
// struct std::basic_common_reference<TTuple, UTuple, TQual, UQual>;
// template <rsl::tuple_like TTuple, rsl::tuple_like UTuple>
// struct std::common_type<TTuple, UTuple>;

// [tuple.traits], allocator-related traits
// template <class... Types, class Alloc>
// struct std::uses_allocator<rsl::tuple<Types...>, Alloc>;

#if RSL_STD_COMPAT
template <class T>
    requires requires { typename rsl::tuple_size<T>; }
struct std::tuple_size<T> : rsl::tuple_size<T> {};

template <std::size_t I, class T>
    requires requires { typename rsl::tuple_element<I, T>; }
struct std::tuple_element<I, T> : rsl::tuple_element<I, T> {};

#endif